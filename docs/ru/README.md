# Интерпретатор для интерпретируемого языка программирования с настраиваемым синтаксисом

[Голиков Кирилл Анатольевич](https://github.com/favorart)

Научный руководитель: [Алисейчик Павел Александрович](http://intsys.msu.ru/staff/aliseychik/)

МГУ им. М.В.Ломоносова

Механико-математический факультет

Кафедра МаТИС

2013

УДК: 004.432.2

*Ключевые слова:* IPL, интерпретируемый язык программирования, настраиваемый синтаксис, 
интерпретатор, естественный язык, лексический анализатор, синонимы, регулярные слова.


## Аннотация

Проект интерпретируемого языка программирования, облегчающего понимание формального математического алгоритма, 
а разработку нового алгоритма более эффективной, 
благодаря упрощению синтаксиса и приближению лексических форм языка программирования к естественным для пользователя. 
Актуальность данной темы: высокая сложность исходных кодов программного обеспечения на практике.


## Введение

В статье рассматривается прототип языка программирования, упрощающего общение заказчика с программистом. 
Хотя способы этого общения давно уже отработаны, например, есть схемы, UML-диаграммы и др., но они – не идеальны, есть куда двигаться. 
Цель данной работы – облегчение чтения сложных исходных кодов программ, путём соединения языка программирования, как естественного языка. 
Идея работы заключается в том, чтобы предоставить интерфейс взаимодействия человека с компьютером без специальных знаков “}_$<<;”, 
т.е. сделать так, чтобы компьютер говорил бы на языке человека, а не наоборот. 
Я считаю, что надо стремиться к тому, чтобы любой смог решить бытовую программную задачу, 
просто отдавая команды на родном языке, и для этого бы не требовались технические знания.

Идея подразумевает язык программирования, код которого казался бы для читателя понятным и естественным, 
не требовалось бы дополнительной документации и комментариев 
в результате получилось, что написанием кода должен заниматься профессионал, понимающий принципы функционирования син-таксиса). 
Язык получил название – *интерпретируемый язык программирования* или IPL.

Язык реализует следующие цели и задачи:

*	*Цель – алгоритм*: нет необходимости уточнения исчерпывающих деталей, затрудняющих понимание алгоритма. Высокий уровень абстракции.
*	*Код представляется, как формальный математический текст*, придание тексту подобного вида слова-ми следования, подведения итогов и возможностью использования вложенных численных пунктов и под-пунктов.
*	*Код, понятный с первого взгляда*. Интерпретатор предоставляет возможность изменения зарегистриро-ванных слов и операций в соответствии с привычками и предпочтениями писателя при написании и читате-ля при чтении.
*	*Код можно локализовать и синтаксис подстраивать под локализацию*. Изменения внешнего вида кодов вплоть до возможности написания программ на родном языке (неясные конструкции могут стать понятнее в контексте). Язык поощряет правильные развёрнутые имена, поддержкой устойчивых словосочетаний есте-ственного языка.
*	*Код является подобием интерфейса*. Заказчик по аналогии смог бы сам подправить код.
*	*Код делает то, что должен делать и не делает ничего, что не должен*. Заказчик может сам убедиться, что проект программы удовлетворяет его требованиям или не удовлетворяет.

Особенности языка IPL:

*	лексический анализатор, учитывающий словосочетания в именах; 
*	изменяемые алфавит и набор регулярных слов; 
*	настраиваемый под предпочтения пользователя синтаксис языка; 
*	простая и понятная семантика; 
*	интеллектуальные типы хранения данных; 
*	встроенные средства оптимизации исполнения.

IPL приближает нас к решению следующих задач:

*	комфортного и быстрого изучения исходников новым программистом;
*	облегчения поддержки программных продуктов;
*	доверие пользователя к программе;
*	улучшение взаимопонимания программиста с заказчиком.

Статья состоит из введения, где дан анализ основных идей и сформулирована цель работы; 
трёх частей: демонстрации настраиваемого синтаксиса языка, функционирования и реализации интерпретатора IPL; 
и заключения, где подведены итоги работы надо проектом.

**Листинг 1.1.**

![1](https://github.com/favorart/IPL/assets/9784285/09371315-ff99-499d-b85c-f48d39dc301b)

_____________________

## 1. Настраиваемый синтаксис

Идеей создания интерпретируемого языка программирования было предоставление возможностей пользователям определять синтаксис, 
исходя из их предпочтений и привычек (листинг 1.1). 
Блоки объявления переменных могут находиться в любых местах программы. В листинге 1.2 пока-заны варианты синтаксиса:

**Листинг 1.2.**

![2](https://github.com/favorart/IPL/assets/9784285/805a65af-e821-4e13-b60d-33deb87c962a)

*Арифметические выражения*. При написании кода с настройкой без явных разделителей, 
логически разделение выражений происходит в соответствии с интуитивным пониманием. 
Алгебраическое выражение считается законченным, если подряд идут не операторы языка: 

$$ а=1+2 \hspace{10pt} [;] \hspace{10pt} b=2+4 $$

В `interpreter.Syntax` имеются настройки (листинг 1.3), задающие вариации написания языковых конструкций. 

**Листинг 1.3.**

![3](https://github.com/favorart/IPL/assets/9784285/70704cd9-32fc-41fc-bca1-c6f9d7ea21c9)


## 2. Функционирование

Интерпретация состоит из трёх фаз:

*Лексический анализ* - выделение из текста атомов и составление списка атомарных слов, 
пропуская нерегистрируемые символы и комментарии.

*Синтаксический анализ* - выделение выражений из списка атомов и 
преобразование арифметических выражений в польскую нотацию с учётом приоритетов операций, 
соответствия типов, доступности функций.

*Выполнение* методом рекурсивного спуска по списку, 
возвращаемые значения функций используются как параметры функций выше по рекурсии.

*Считывание и запись пред-компилированного байт-кода*. 
При запуске скрипта интерпретатор проверяет наличие в текущей папке готовых пред-компилированных файлов. 
В случае успеха, пропуская фазы лексического и синтаксического анализа кода, 
а также конфигурирования синтаксиса интерпретатор переходит непосредственно к исполнению. 
Так происходит увеличение быстродействия.


### 2.1. Пред-компиляция в байт-код

Программист пишет скрипт IPL в текстовом файле в соответствии с его конфигурацией интерпретатора 
и получает файл `.ipl` (interpreted pre-compiled). 
При выполнении файла в памяти интерпретатора создаётся пред-компилированная версия исходных кодов программы, 
понятная только интерпретатору.
Предкомпиляция создаёт три файла с данными и файл с байт-кодом:

		<script name>.ipc.constants.dat
		<script name>.ipc.variables.dat
		<script name>.<conf>.ipc.reg_words.dat
		<script name>.ipc

При создании байт-кода, выбрасываются все блоки объявления переменных, 
и создаётся отдельная хэш-таблица специально для хранения начальных значений переменных – 
она записывается в `variables.dat`.

В начале считывания сравниваются хэши `{1}` в файле байт-кода и исходника выполняемой программы. 
Далее файл состоит из троек четырёхбайтных чисел, которые определяют код. 
Самой первой тройкой идёт список верхнего уровня, хранящий все выражения и блоки кода. 
Далее его элементы, и т.д. рекурсивно вкладывается программа (табл.2.1).

**Таблица 2.1.**

| заголовок файла [32 байта]                    |
|:---------------------------------------------:|
| хэш-сумма sha256 файла c исполняемым скриптом |

| тип атома                     | смещение в таблице  | смещение в цепочке    |                   |
|:-----------------------------:|:-------------------:|:---------------------:|:------------------|
|в какой хэш-таблице будет поиск|от начала хэш-таблицы|на элементе хэш-таблицы|
| [ sizeof (int) ]              | [ sizeof (int) ]    | [ sizeof (int) ]      |
| PreComp                       | 0                   | number of elements    |выражение языка (список)
| Constant                      | 476                 | 0                     |значение константы
| Variable                      | 165                 | 0                     |переменная языка
| RegWord                       | 634                 | 2                     |регулярное слово языка
| ...                           | ...                 | ...                   |


### 2.2. Фаза лексического анализа

Как было сказано выше для лучшей наглядности алгоритма на IPL используются синонимы регулярных слов и идентификаторы, 
состоящие из нескольких *слово-составляющих* (будем так называть слова естественного языка, для предотвращения путаницы), 
а также недопустимы неестественные префиксы и символы. Вследствие чего механизм лексического анализа интерпретатора, 
был написан с учётом необходимости догадываться по порядку слов в выражении языка и из контекста. 
Анализ текста происходит в два этапа: сначала байты файла на диске 
(`TODO: unicode пока не реализован, работа со строками происходит в ASCII`) 
группируются в простые составляющие слов, которые приводятся к *нормализованному виду*. 
Их список передаётся на этап выше, где из них, если их хватает, конструируются *атомы* языка, 
в противном случае снова вызывается анализатор первого уровня. 
Результатом лексического анализа является последовательный список атомов (рис.2.1):

**Рис 2.1.** `ipl_list_pmv list_of_atoms`

![2 1](https://github.com/favorart/IPL/assets/9784285/5bf1d652-95df-426b-90d2-7b09e57d59d4)

Анализатор работает с помощью настройки *файлами конфигурации*. 
Все символы задаются в файле настроек алфавита 
(`<conf>_charset.txt`, где `<conf>` задаётся пользователем, например, `eng` или `rus`). 
В нём символы делятся на 5 непересекающихся классов: буквы, знаки, цифры, символ кавычек и символ десятичной точки. 
Символы задаются пользователем и могут быть произвольными – интерпретатор не зависит от конкретных букв и знаков.

Другим конфигурационным файлом является файл регулярных слов (`<conf>.txt`). 
Выглядит следующим образом: уникальный идентификатор смысла слова (полученный из `reg.word.id.txt`), 
за ним через запятую следуют синонимы, обозначающие это регулярное слово, в конце необязательный поясняющий комментарий. 
Регулярные слова известны анализатору во время выполнения.
 Синонимы синхронизируются синтаксическом анализатором.


### 2.3. Фаза синтаксического анализа

Задачами синтаксического анализатора являются: 

1. корректная обработка вариаций исходников и приведение их к единому байт-коду;
2. перестановка инструкций в соответствии с приоритетами.

Таким образом, исполнитель занимается только последовательным выполнением инструкций. 

Задача (1) тривиальна и заключается в последовательном опросе лексического анализатора за очередной порцией атомов, 
после получения которой, проверяется смысл слов, если очередное слово недопустимо, то выдаётся соответствующая ошибка. 

Задача (2) заключается в выделении выражений из списка атомов и преобразование арифметических действий 
в *прямую польскую нотацию с помощью программного стека* `{3}`. 
Здесь синтаксический анализатор приводит выражение из infix в prefix нотацию, т.е. $(1+2)$ в $(+,1,2)$.

Кроме того, если в процессе работы синтаксический анализатор находит слишком длинные строки и глубокие вложения, 
он выдаёт предупреждения о том, что написанные программистом конструкции, возможно, слишком запутаны, 
и пользователю будет трудно понять эту часть алгоритма. 
На рисунке 2.2 приведён пример успешно завершённой фазы синтаксического анализа в интерпретаторе IPL для операции ветвления.

**Рис.2.2.** Оператор ветвления в IPL.

![2 2](https://github.com/favorart/IPL/assets/9784285/430e7237-9c07-415f-a2d7-78b3b91fec57)

В итоге, *синтаксис* IPL обладает следующими особенностями:

*	объявление переменных производится в отдельном блоке;
*	имеется несколько альтернатив синтаксиса методов объектов и циклов;
*	возможно указать пункты в блоках кода, которые проясняют структуру блока и обеспечивают более строгое направления взгляда;
*	директива `resulted`, позволяющая любому блоку кода возвращать результат.

В языке IPL нет привычных для программиста двух типов *скобок*: *функциональных* и *структурных*. 
Это сделано в целях реализации парадигмы, когда любой блок кода может возвращать значение, приравниваясь к выражению. 
Блок кода можно использовать даже внутри параметров функции, если он возвращает значение и не затрудняет понимание программы.


### 2.4. Фаза выполнения

Интерпретатор методом *рекурсивного спуска* `{2}` исполняет байт-код, 
показанный на рисунке 2.2, представляющий собой вложенные списки атомов. 
При выполнении инструкций программа *схлопывается* – 
обрабатываемое выражение извлекается из списка, а вместо него записывается результат ($1+2 \to 3$). 
В структуре исполнителя извлекаемые элементы не удаляются, 
а перемещаются из выполняемого выражения в сохраняющее выражение. 
Таким образом, пред-компилированный байт-код, проверенный на корректность выполнением, 
остаётся доступным для записи в файл или для использования в циклах и функциях. 
Программа завершается, когда в списке исполняемых инструкций не остаётся элементов [1].


## 3. Реализация

Кирпичиками, из которых состоит интерпретатор, являются структуры `myvar` (листинг 3.1), в зависимости от значений в них 
атомарный элемент языка может быть знаком, регулярным словом, константой, переменной и даже целым выражением. 
На то, чем атом является, указывают поля нумераторов.

**Листинг 3.1.**

![3 1](https://github.com/favorart/IPL/assets/9784285/46fa5a6f-91e1-4ca1-b326-d95c5cc8e87b)

Данные интерпретатора хранятся в структуре под названием *таблица имён* (`names_table`). 
С её инициализации стартует интерпретатор, её очисткой он заканчивает. 
Таблица хранит данные, необходимые на разных этапах выполнения скрипта. 
Например, на этапах формирования лексем и синтаксиса, а также важные данные, 
необходимые всегда – словари переменных, констант, регулярных слов и выражений.

Таким образом, динамическая память каким-нибудь образом заносится в этот реестр, 
чем гарантируется, что вся выделенная память будет своевременно и целиком очищена. 
Так решается проблема сборки мусора.


## 4. Типизация

В языке IPL решено не использовать *неявную типизацию*, 
т.к. сложно отличить неявное объявление переменной от ссылки на неё и трудно проследить область видимости переменной в тексте программы. 
Но, при этом, не отказываться от *динамической типизации* [5], чтобы не ограничивать программиста жёсткой статической типизацией, 
предоставляя удобства интерпретируемого языка, при этом иметь возможность ловить ошибки, связанные с типами данных. 
Выбрана *смешанная типизация*, т.е. при создании переменной необходимо явно указывать её тип, но есть возможность, менять этот тип, когда будет надо.

Встроенные типы языка представлены в таблице 3.1.

**Таблица 3.1.**

| тип данных               | диапазон значений
|:-------------------------|:-----------------------------------:|
| целое число              | от -2 147 483 647 до 2 147 483 647
| число с плавающей точкой | 1E-37 до 1E+37
| строка                   | последовательность ASСII символов
| функция                  |
| контейнер                | список или массив
| словарь                  | динамический аналог структуры

IPL поддерживает модульное программирование с использованием функций в отдельных файлах. 
Все функции – глобальные, все переменные – локальные. 
Переменные передаются в функцию по значению. 
Реализация функции внутри структуры `myvar` – это целый малый интерпретатор: 
имеется свой файл скрипта, свой лексический анализатор, свой пред-компилированный код. 
Описание функции необходимо в случае, если её определение находится в другом файле. 
Если имя файла не указано в описании, то поиск файла будет осуществляться 
по имени идентичному имени функции + расширение файла `.ipl` в папке по умолчанию. 

Невозможно представить современный язык программирования без *перечислимых типов данных*: 
словарей и контейнеров. 
Эти типы встроены в ядро и имеют привычные методы использования. 
Особенностью контейнера IPL, который может хранить элементы любых типов один за другим, 
является то, что в зависимости от частоты использования пользователем определённых операций, 
контейнер сам принимает решение о способе хранения элементов 
(можно изначально указать тип хранения для контейнера) – это может быть двусвязный список или непрерывный массив.

Как известно, массив эффективен для чтения в режиме случайного доступа, но неэффективен для случайной записи. 
Иначе для списка, вставка – лёгкая операция, а для индексации в середину нужно перебрать половину элементов. 
Если неудобные операции для конкретного способа хранения производятся систематически, 
то имеет смысл перейти на другой способ хранения, несмотря на затраты на переформирование. 
Контейнер следит за общим числом, а также за длиной серий последовательных вставок и обращений по адресам. 
При очередном действии увеличиваются или уменьшаются счётчики внутри конкретного экземпляра контейнера. 
Пороговые значения были подобраны экспериментальным путём.

Тип данных словарь (`joint`) – это множество пар `key:value`, 
где `key` и `value` – некоторые типы данных. 
Значение `value` может быть получено за константное время по значению `key` из словаря, если оно там есть. 
В противном случае будет возвращён ‘отказ’. 
Словари на базе хэш-таблиц {4} используются, как аналог пользовательских типов (`struct` в языке Си). 
Такой путь распространён среди интерпретируемых языков, 
т.к. позволяет определять структуру объединения динамически в ходе выполнения программы. 


## Заключение

В данной статье представлены результаты исследовательской работы по созданию интерпретатора языка IPL. 
На примере текста в листинге 4.1, демонстрируются читабельность кода и многие возможности языка. 
Как Вы могли убедиться из представленных исходников на IPL, 
он приближает нас ещё на шаг к использованию естественного языка при программировании.

**Листинг 4.1.** Задача о рюкзаке

![4 1](https://github.com/favorart/IPL/assets/9784285/ee554a40-3c85-4684-b2ec-129a0da78021)

_____________________

**Листинг 4.2.** Программа с порядком сложности $O(n^2)$

![4 2](https://github.com/favorart/IPL/assets/9784285/80204cf2-5f07-492f-9add-cc38e3709e2b)

_____________________

**Листинг 4.3.** Программа на узбекском языке

![4 3](https://github.com/favorart/IPL/assets/9784285/8e0f53e5-8e0a-47e4-9c01-8c3bd6e48849)

_____________________

## Список использованной литературы

* [1]	Шилдт Г. Язык С для профессиональных программистов. / Born to Code in C. – Osborne, 1989
* [2]	Керниган Б., Ритчи Д. Язык программирования С. / The C Programming Language. – Prentice Hall, 1988
* [3]	[Пример написания простого интерпретатора](http://rsdn.ru/forum/alg/5018812.all)
* [4]	[Сам себе интерпретатор](http://coderszone.info/339-sam-sebe-interpretator.html)
* [5]	[Динамическая типизация данных](http://ru.wikipedia.org/wiki/Динамическая_типизация)


### Использованные алгоритмы

*	{1}	[Метод вычисления хэш-суммы файла SHA256 (Ch.Devine, 2003)](http://patux.net/crypto_programs/hash/sha-2/sha256.c.html)
*	{2}	[Метод рекурсивного спуска](http://en.wikipedia.org/wiki/Recursive_descent_parser)
*	{3}	[Построение прямой польской нотации методом программного стека](http://algolist.manual.ru/maths/misc/revpn.php)
*	{4}	Построение хэш-таблиц
*	Хэш-адрес равен остатку от деления на простое число (А.Думи, 1956)
*	Метод цепочек (Г.П.Лан, 1953)
*	Метод открытой адресации (пробирования) (А.П.Ершов, 1953), (в иностранной литературе – Ж.Амдал, 1957)
*	{5}	Сортировки
*	Быстрая сортировка (Ч.Хоар, 1960), pеализация из <stdlib.h>
*	Алгоритм сортировки слиянием для списков (Дж. фон Нейман, 1945)

